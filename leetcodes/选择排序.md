# 选择排序

## 思路

每一次都选取`未排定部分`的最小元素，交换到`未排定部分的第一个位置`

```js
for (var i=0; i< nums.length -1; i ++) {
  for (var j=i; j< nums.length; j ++) {
    if (nums[i] <  nums[j]) {
      // swap
    }
  }
}
```

## 特点

1. 交换的次数最少
 
 > 如果一个排序任务交换的成本很高，可以考虑使用选择排序。

2. 运行时间与输入无关
  
> 每一趟扫描，除了扫描的元素比上一轮少了一个以外，选择排序没有记住更多的信息。一个极端的例子是，已经是排好序的数组，选择排序还需要一次又一次地扫描。

## 体现的算法思想

1. 贪心算法

> 局部最优，则整体最优（每次都在未排定部分选取最小值）。贪心算法的证明要用到`循环不变量`的概念

2. 减而治之
  
## 冒泡排序

1. 比较相邻的元素。如果第一个比第二个大（小），就交换他们两个。

2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大（小）的数。

3. 针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。

4. 持续每次对越来越少的元素（无序元素）重复上面的步骤，直到没有任何一对数字需要比较，则序列最终有序。

```js
for (var i=0; i< nums.length -1; i ++) {
  for (var j=0; j< nums.length - i; j ++) {
    if (nums[j] < nums[j + 1]) {
       // swap
    }
  }
}
```